// lib/features/journal/journal_entry_editor.dart
//
// v9.1 — JournalEntryEditor (Oxford-Zen, SenStyleDart)
// -----------------------------------------------------------------------------
// • Ruhiger Editor nur für Journal-Einträge (EntryKind.journal) – optional
//   Titelzeile, die beim Speichern in den Body gemerged wird.
// • Mood-Auswahl (ChoiceChips) → wird als Tag "mood:<Label>" persistiert.
// • Zwei Aktionen: ① Speichern (Tagebuch) ② Als Reflexion speichern.
// • Quick-Append-Leiste unten (Mic + Senden) fügt zum Haupttext an.
// • Auto-Clean-Pipeline: vorsichtig & idempotent (Whitespace/Interpunktion,
//   Ellipsen, Gedankenstrich, häufige DE-Tippfehler) – keine Paraphrase.
// • Edit-Modus: vorhandenen Journal-Text überschreiben; Mood-Tag wird
//   ersetzt (vorhandene mood:/moodScore: im Tag-Set werden entfernt).
//
// Abhängigkeiten:
//   zen_style.dart als `zs` (ohne Widgets), zen_widgets.dart als `zw`
//   providers/journal_entries_provider.dart als `jp`
//   models/journal_entry.dart als `jm`
//   services/speech_service.dart (transcript$ / start / stop / isRecording)

import 'dart:async';

import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter/scheduler.dart' show Ticker, TickerProvider, TickerCallback;
import 'package:provider/provider.dart';

import '../../shared/zen_style.dart' as zs hide ZenBackdrop, ZenGlassCard, ZenAppBar;
import '../../shared/ui/zen_widgets.dart' as zw
    show ZenBackdrop, ZenGlassCard, ZenAppBar, PandaHeader, ZenToast;

import '../../providers/journal_entries_provider.dart' as jp;
import '../../models/journal_entry.dart' as jm;
import '../../services/speech_service.dart';

class JournalEntryEditor extends StatefulWidget {
  /// Optional: vorhandener Eintrag (nur EntryKind.journal vorgesehen).
  final jm.JournalEntry? existing;

  /// Optionaler Seed-Text/Überschrift.
  final String? initialText;
  final String? initialTitle;

  /// Optionaler Start-Mood (Glücklich/Ruhig/Neutral/Traurig/Gestresst/Wütend)
  final String? initialMood;

  /// Callback nach erfolgreichem Speichern.
  final VoidCallback? onSaved;

  const JournalEntryEditor({
    super.key,
    this.existing,
    this.initialText,
    this.initialTitle,
    this.initialMood,
    this.onSaved,
  });

  @override
  State<JournalEntryEditor> createState() => _JournalEntryEditorState();
}

class _JournalEntryEditorState extends State<JournalEntryEditor> {
  static const Duration _animShort = Duration(milliseconds: 200);
  static const List<String> _moods = <String>[
    'Glücklich', 'Ruhig', 'Neutral', 'Traurig', 'Gestresst', 'Wütend'
  ];

  final TextEditingController _titleCtrl  = TextEditingController();
  final TextEditingController _editorCtrl = TextEditingController();
  final TextEditingController _quickCtrl  = TextEditingController();

  final FocusNode _titleFocus  = FocusNode();
  final FocusNode _editorFocus = FocusNode();
  final FocusNode _quickFocus  = FocusNode();
  final FocusNode _pageFocus   = FocusNode();

  final ScrollController _scroll = ScrollController();
  late final AnimationController _fadeCtrl;

  final SpeechService _speech = SpeechService();
  StreamSubscription<String>? _speechSub;

  String _mood = 'Neutral';
  bool _saving = false;

  @override
  void initState() {
    super.initState();
    _fadeCtrl = AnimationController(vsync: _TickerProvider(this), duration: _animShort);

    // Seed aus existing / Props
    final ex = widget.existing;
    if (ex != null && ex.kind == jm.EntryKind.journal) {
      _editorCtrl.text = (ex.thoughtText ?? '').trim();
      _titleCtrl.text  = ''; // Titel wird als Teil des Texts geführt
      _mood = ex.moodLabel.trim().isNotEmpty == true ? ex.moodLabel.trim() : 'Neutral';
    } else {
      _editorCtrl.text = (widget.initialText ?? '').trim();
      _titleCtrl.text  = (widget.initialTitle ?? '').trim();
      _mood = (widget.initialMood ?? (_editorCtrl.text.isEmpty && _titleCtrl.text.isEmpty ? 'Neutral' : 'Ruhig'));
    }

    // Mic → Quick-Input
    _speechSub = _speech.transcript$.listen((t) {
      if (!mounted) return;
      WidgetsBinding.instance.addPostFrameCallback((_) {
        if (!mounted) return;
        final cur = _quickCtrl.text.trim();
        final joined = (cur.isEmpty ? t : '$cur\n$t').trim();
        _quickCtrl.text = joined;
        _quickCtrl.selection = TextSelection.fromPosition(TextPosition(offset: _quickCtrl.text.length));
        FocusScope.of(context).requestFocus(_quickFocus);
      });
    });

    _fadeCtrl.forward(from: 0);
  }

  @override
  void dispose() {
    _speechSub?.cancel();
    _speech.dispose();
    _titleCtrl.dispose();
    _editorCtrl.dispose();
    _quickCtrl.dispose();
    _titleFocus.dispose();
    _editorFocus.dispose();
    _quickFocus.dispose();
    _pageFocus.dispose();
    _scroll.dispose();
    _fadeCtrl.dispose();
    super.dispose();
  }

  // ---------------- Keyboard Shortcuts ---------------------------------------

  KeyEventResult _handleKey(KeyEvent e) {
    if (e.logicalKey == LogicalKeyboardKey.escape && _speech.isRecording) {
      _toggleMic();
      return KeyEventResult.handled;
    }
    final isEnter = e.logicalKey == LogicalKeyboardKey.enter || e.logicalKey == LogicalKeyboardKey.numpadEnter;
    final withCtrlOrCmd = e.isControlPressed || e.isMetaPressed;
    if (withCtrlOrCmd && isEnter) {
      _appendQuick();
      return KeyEventResult.handled;
    }
    if (withCtrlOrCmd && e.logicalKey == LogicalKeyboardKey.keyS) {
      _save(asReflection: false);
      return KeyEventResult.handled;
    }
    return KeyEventResult.ignored;
  }

  // ---------------- Actions ---------------------------------------------------

  void _appendQuick() {
    final add = _quickCtrl.text.trim();
    if (add.isEmpty) return;
    final base = _editorCtrl.text.trimRight();
    final next = base.isEmpty ? add : '$base\n\n$add';
    setState(() => _editorCtrl.text = next);
    _editorCtrl.selection = TextSelection.fromPosition(TextPosition(offset: _editorCtrl.text.length));
    _quickCtrl.clear();
    _scrollToBottom();
    HapticFeedback.selectionClick();
  }

  Future<void> _toggleMic() async {
    try {
      if (_speech.isRecording) {
        await _speech.stop();
        if (!mounted) return;
        FocusScope.of(context).requestFocus(_quickFocus);
      } else {
        HapticFeedback.selectionClick();
        FocusScope.of(context).unfocus();
        await _speech.start();
      }
      if (mounted) setState(() {});
    } catch (_) {
      zw.ZenToast.show(context, 'Mikrofon nicht verfügbar. Erlaube bitte den Zugriff.');
    }
  }

  void _autoClean() {
    final before = _editorCtrl.text;
    final after  = _autoCleanPipeline(before);
    if (after != before) {
      setState(() => _editorCtrl.text = after);
      _editorCtrl.selection = TextSelection.fromPosition(TextPosition(offset: _editorCtrl.text.length));
    }
    HapticFeedback.selectionClick();
    zw.ZenToast.show(context, 'Text vorsichtig korrigiert');
  }

  Future<void> _save({required bool asReflection}) async {
    if (_saving) return;

    final bodyRaw  = _editorCtrl.text.trim();
    final titleRaw = _titleCtrl.text.trim();

    if (bodyRaw.isEmpty && titleRaw.isEmpty) {
      zw.ZenToast.show(context, 'Schreibe erst etwas in deinen Eintrag.');
      FocusScope.of(context).requestFocus(_editorFocus);
      return;
    }

    setState(() => _saving = true);
    try {
      final cleaned = _autoCleanPipeline(bodyRaw);
      final merged  = titleRaw.isEmpty ? cleaned : '$titleRaw\n\n$cleaned';

      final prov = context.read<jp.JournalEntriesProvider>();

      if (asReflection) {
        // Immer NEUE Reflexion (Journal-Editor erstellt/ändert keine Stories)
        prov.addReflection(text: merged, moodLabel: _mood, aiQuestion: null);
      } else {
        final ex = widget.existing;
        if (ex != null) {
          // Tags: mood:* ersetzen (und moodScore:*), Rest beibehalten
          final nextTags = <String>[
            ...ex.tags.where((t) => !t.startsWith('mood:') && !t.startsWith('moodScore:')),
            if (_mood.trim().isNotEmpty) 'mood:${_mood.trim()}',
          ];
          prov.updateById(
            ex.id,
            thoughtText: merged,
            tags: nextTags,
            createdAt: ex.createdAt, // ruhige Chronologie beibehalten
            kind: jm.EntryKind.journal,
          );
        } else {
          prov.addDiary(text: merged, moodLabel: _mood);
        }
      }

      zw.ZenToast.show(context, asReflection ? 'Reflexion gespeichert' : 'Eintrag gespeichert');
      widget.onSaved?.call();
      if (mounted) Navigator.of(context).maybePop();
    } finally {
      if (mounted) setState(() => _saving = false);
    }
  }

  // ---------------- Auto-Clean Pipeline --------------------------------------

  String _autoCleanPipeline(String input) {
    var s = input;

    // Zeilenenden normalisieren
    s = s.replaceAll('\r\n', '\n').replaceAll('\r', '\n');

    // Trailing-Whitespace je Zeile entfernen
    s = s.split('\n').map((l) => l.replaceAll(RegExp(r'[ \t]+$'), '')).join('\n');

    // Mehrfach-Leerzeilen → max. 2
    s = s.replaceAll(RegExp(r'\n{3,}'), '\n\n');

    // Mehrfach-Spaces → Single (Tabs/Zeilenumbrüche bleiben)
    s = s.replaceAll(RegExp(r'[ ]{2,}'), ' ');

    // Space vor Satzzeichen korrigieren
    s = s.replaceAll(RegExp(r'\s+([,.;:!?])'), r'$1');

    // Space nach Satzzeichen ergänzen (falls Zeichen folgt)
    s = s.replaceAllMapped(RegExp(r'([,.!?;:])(?!\s|\n|$)'), (m) => '${m.group(1)} ');

    // Ellipsen
    s = s.replaceAll(RegExp(r'\.{3,}'), '…');
    s = s.replaceAll(RegExp(r'…{2,}'), '…');

    // Gedankenstrich
    s = s.replaceAll(RegExp(r'(?<=\w)\s-\s(?=\w)'), ' – ');

    // Doppelte Satzzeichen zusammenziehen
    s = s.replaceAll(RegExp(r'([!?])\s+\1'), r'$1$1');

    // Häufige DE-Tippfehler (sehr konservativ)
    final Map<RegExp, String> typo = <RegExp, String>{
      RegExp(r'\bvieleicht\b', caseSensitive: false): 'vielleicht',
      RegExp(r'\bdefinitv\b', caseSensitive: false): 'definitiv',
      RegExp(r'\bstandart\b', caseSensitive: false): 'Standard',
      RegExp(r'\bseperat\b', caseSensitive: false): 'separat',
      RegExp(r'\binterres+', caseSensitive: false): 'interess',
      RegExp(r'\bwiederspiegeln\b', caseSensitive: false): 'widerspiegeln',
      RegExp(r'\bgramatik\b', caseSensitive: false): 'Grammatik',
      RegExp(r'\bacc?ept\b', caseSensitive: false): 'accept',
    };
    typo.forEach((rx, repl) {
      s = s.replaceAllMapped(rx, (m) {
        final g = m.group(0) ?? '';
        if (g.isNotEmpty && g[0].toUpperCase() == g[0]) {
          return repl.isEmpty ? repl : '${repl[0].toUpperCase()}${repl.substring(1)}';
        }
        return repl;
      });
    });

    // Letzte Kosmetik
    s = s.replaceAll(RegExp(r'[ \t]+\n'), '\n');
    s = s.trimRight();
    return s;
  }

  // ---------------- UI -------------------------------------------------------

  @override
  Widget build(BuildContext context) {
    final overlay = Theme.of(context).brightness == Brightness.dark
        ? SystemUiOverlayStyle.light
        : SystemUiOverlayStyle.dark;

    final isMobile = MediaQuery.of(context).size.width < 560;
    final pandaSize = MediaQuery.of(context).size.width < 470 ? 88.0 : 112.0;

    return AnnotatedRegion<SystemUiOverlayStyle>(
      value: overlay,
      child: KeyboardListener(
        focusNode: _pageFocus,
        autofocus: true,
        onKey: _handleKey,
        child: Scaffold(
          extendBodyBehindAppBar: true,
          backgroundColor: Colors.transparent,
          appBar: const zw.ZenAppBar(title: null, showBack: true),
          body: Stack(
            children: [
              const Positioned.fill(
                child: zw.ZenBackdrop(
                  asset: 'assets/schoen.png',
                  alignment: Alignment.center,
                  glow: .36,
                  vignette: .12,
                  enableHaze: true,
                  hazeStrength: .12,
                  saturation: .94,
                  wash: .08,
                ),
              ),
              SafeArea(
                child: Column(
                  children: [
                    Padding(
                      padding: EdgeInsets.only(
                        left: zs.ZenSpacing.m,
                        right: zs.ZenSpacing.m,
                        top: isMobile ? 16 : 20,
                        bottom: 10,
                      ),
                      child: zw.PandaHeader(
                        title: widget.existing == null ? 'Neuer Eintrag' : 'Eintrag bearbeiten',
                        caption: 'Schreibe in Ruhe. Ich bin hier.',
                        pandaSize: pandaSize,
                        strongTitleGreen: true,
                      ),
                    ),

                    // Inhalt
                    Expanded(
                      child: FadeTransition(
                        opacity: _fadeCtrl.drive(Tween(begin: 0.0, end: 1.0)),
                        child: ListView(
                          controller: _scroll,
                          physics: const BouncingScrollPhysics(),
                          padding: const EdgeInsets.fromLTRB(
                            zs.ZenSpacing.m, 0, zs.ZenSpacing.m, zs.ZenSpacing.s,
                          ),
                          children: [
                            // Titel
                            zw.ZenGlassCard(
                              padding: const EdgeInsets.fromLTRB(16, 12, 16, 10),
                              borderRadius: const BorderRadius.all(zs.ZenRadii.xl),
                              topOpacity: .30,
                              bottomOpacity: .14,
                              borderOpacity: .18,
                              child: TextField(
                                controller: _titleCtrl,
                                focusNode: _titleFocus,
                                textInputAction: TextInputAction.next,
                                onSubmitted: (_) => _editorFocus.requestFocus(),
                                spellCheckConfiguration: const SpellCheckConfiguration.disabled(),
                                autocorrect: false,
                                enableSuggestions: true,
                                decoration: const InputDecoration(
                                  hintText: 'Überschrift (optional)',
                                  border: InputBorder.none,
                                  isCollapsed: true,
                                ),
                                style: Theme.of(context).textTheme.titleMedium?.copyWith(
                                  color: zs.ZenColors.jade,
                                  fontWeight: FontWeight.w800,
                                  height: 1.22,
                                ),
                              ),
                            ),
                            const SizedBox(height: 10),

                            // Haupt-Editor
                            zw.ZenGlassCard(
                              padding: const EdgeInsets.fromLTRB(16, 14, 16, 14),
                              borderRadius: const BorderRadius.all(zs.ZenRadii.xl),
                              topOpacity: .30,
                              bottomOpacity: .14,
                              borderOpacity: .18,
                              child: Column(
                                crossAxisAlignment: CrossAxisAlignment.stretch,
                                children: [
                                  TextField(
                                    controller: _editorCtrl,
                                    focusNode: _editorFocus,
                                    keyboardType: TextInputType.multiline,
                                    maxLines: null,
                                    minLines: 10,
                                    textInputAction: TextInputAction.newline,
                                    autocorrect: true,
                                    enableSuggestions: true,
                                    spellCheckConfiguration: const SpellCheckConfiguration.disabled(),
                                    style: Theme.of(context).textTheme.bodyMedium?.copyWith(
                                      color: zs.ZenColors.jade,
                                      height: 1.35,
                                      fontWeight: FontWeight.w600,
                                    ),
                                    cursorColor: zs.ZenColors.jade,
                                    decoration: InputDecoration(
                                      hintText: 'Schreib, was du festhalten möchtest …',
                                      hintStyle: Theme.of(context).textTheme.bodyMedium?.copyWith(
                                        color: zs.ZenColors.jade.withValues(alpha: .55),
                                        fontWeight: FontWeight.w500,
                                      ),
                                      border: InputBorder.none,
                                      isCollapsed: true,
                                    ),
                                  ),
                                  const SizedBox(height: 10),
                                  // Tools: Korrigieren
                                  Row(
                                    children: [
                                      OutlinedButton.icon(
                                        onPressed: _autoClean,
                                        icon: const Icon(Icons.spellcheck),
                                        label: const Text('Korrigieren'),
                                        style: OutlinedButton.styleFrom(
                                          minimumSize: const Size(0, 42),
                                          shape: const RoundedRectangleBorder(
                                            borderRadius: BorderRadius.all(zs.ZenRadii.m),
                                          ),
                                        ),
                                      ),
                                      const Spacer(),
                                      Text(
                                        '${_editorCtrl.text.trim().length} Zeichen',
                                        style: Theme.of(context).textTheme.labelSmall?.copyWith(
                                          color: zs.ZenColors.inkSubtle,
                                        ),
                                      ),
                                    ],
                                  ),
                                ],
                              ),
                            ),
                            const SizedBox(height: 12),

                            // Mood
                            _MoodRow(
                              selected: _mood,
                              onSelect: (m) => setState(() => _mood = m),
                            ),
                            const SizedBox(height: 8),

                            // Hinweiszeile
                            Align(
                              alignment: Alignment.center,
                              child: Text(
                                'Bleibt lokal. Teilen ist optional.',
                                style: Theme.of(context).textTheme.labelSmall?.copyWith(
                                  color: zs.ZenColors.inkSubtle,
                                ),
                              ),
                            ),
                            const SizedBox(height: 12),

                            // Aktionen
                            Wrap(
                              alignment: WrapAlignment.center,
                              spacing: 10,
                              runSpacing: 10,
                              children: [
                                SizedBox(
                                  width: 280,
                                  child: ElevatedButton.icon(
                                    onPressed: _saving ? null : () => _save(asReflection: false),
                                    icon: _saving
                                        ? const SizedBox(width: 18, height: 18, child: CircularProgressIndicator(strokeWidth: 2))
                                        : const Icon(Icons.check_circle_rounded),
                                    label: Text(_saving ? 'Speichern …' : 'Speichern'),
                                    style: ElevatedButton.styleFrom(
                                      minimumSize: const Size(0, 48),
                                      shape: const RoundedRectangleBorder(
                                        borderRadius: BorderRadius.all(zs.ZenRadii.m),
                                      ),
                                    ),
                                  ),
                                ),
                                SizedBox(
                                  width: 280,
                                  child: OutlinedButton.icon(
                                    onPressed: _saving ? null : () => _save(asReflection: true),
                                    icon: const Icon(Icons.psychology_alt_rounded),
                                    label: const Text('Als Reflexion speichern'),
                                    style: OutlinedButton.styleFrom(
                                      minimumSize: const Size(0, 48),
                                      shape: const RoundedRectangleBorder(
                                        borderRadius: BorderRadius.all(zs.ZenRadii.m),
                                      ),
                                    ),
                                  ),
                                ),
                              ],
                            ),
                            const SizedBox(height: 6),
                          ],
                        ),
                      ),
                    ),

                    // Bottom Quick-Append
                    Padding(
                      padding: const EdgeInsets.fromLTRB(
                        zs.ZenSpacing.m, 0, zs.ZenSpacing.m, zs.ZenSpacing.s,
                      ),
                      child: _QuickAppendBar(
                        controller: _quickCtrl,
                        focusNode: _quickFocus,
                        isRecording: _speech.isRecording,
                        onMicToggle: _toggleMic,
                        onSend: _appendQuick,
                      ),
                    ),
                  ],
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }

  void _scrollToBottom() {
    WidgetsBinding.instance.addPostFrameCallback((_) {
      if (!_scroll.hasClients) return;
      _scroll.animateTo(
        _scroll.position.maxScrollExtent,
        duration: _animShort,
        curve: Curves.easeOut,
      );
    });
  }
}

// ---------------- Widgets (intern) -------------------------------------------

class _MoodRow extends StatelessWidget {
  final String selected;
  final ValueChanged<String> onSelect;

  const _MoodRow({
    required this.selected,
    required this.onSelect,
  });

  static const List<String> _moods = <String>[
    'Glücklich', 'Ruhig', 'Neutral', 'Traurig', 'Gestresst', 'Wütend',
  ];

  @override
  Widget build(BuildContext context) {
    return Wrap(
      spacing: 8,
      runSpacing: 6,
      alignment: WrapAlignment.center,
      children: _moods.map((m) {
        final isSel = m == selected;
        return ChoiceChip(
          label: Text(m),
          selected: isSel,
          onSelected: (_) => onSelect(m),
          visualDensity: VisualDensity.compact,
          materialTapTargetSize: MaterialTapTargetSize.shrinkWrap,
          selectedColor: zs.ZenColors.jade.withValues(alpha: .10),
          side: BorderSide(
            color: isSel
                ? zs.ZenColors.jade.withValues(alpha: .55)
                : zs.ZenColors.jade.withValues(alpha: .22),
          ),
          shape: const StadiumBorder(),
        );
      }).toList(),
    );
  }
}

class _QuickAppendBar extends StatelessWidget {
  final TextEditingController controller;
  final FocusNode? focusNode;
  final VoidCallback onSend;
  final VoidCallback onMicToggle;
  final bool isRecording;

  const _QuickAppendBar({
    required this.controller,
    this.focusNode,
    required this.onSend,
    required this.onMicToggle,
    required this.isRecording,
  });

  @override
  Widget build(BuildContext context) {
    const jade = zs.ZenColors.jade;
    final baseText = Theme.of(context).textTheme.bodyMedium!;
    final hintStyle = baseText.copyWith(color: jade.withValues(alpha: 0.55));

    final List<BoxShadow> pulse = isRecording
        ? [
            BoxShadow(color: Colors.black.withValues(alpha: 0.10), blurRadius: 14, offset: const Offset(0, 4)),
            BoxShadow(color: jade.withValues(alpha: 0.30), blurRadius: 22, spreadRadius: 1.2),
          ]
        : [
            const BoxShadow(color: Color(0x14000000), blurRadius: 18, offset: Offset(0, 6)),
          ];

    return Container(
      decoration: BoxDecoration(
        color: zs.ZenColors.white,
        borderRadius: const BorderRadius.all(zs.ZenRadii.l),
        border: Border.all(color: jade.withValues(alpha: 0.75), width: 2),
        boxShadow: pulse,
      ),
      padding: const EdgeInsets.fromLTRB(12, 8, 8, 8),
      child: ValueListenableBuilder<TextEditingValue>(
        valueListenable: controller,
        builder: (context, value, _) {
          final hasText = value.text.trim().isNotEmpty;
          return TextField(
            focusNode: focusNode,
            controller: controller,
            maxLines: null,
            minLines: 1,
            textInputAction: TextInputAction.newline,
            keyboardType: TextInputType.multiline,
            autocorrect: false,
            enableSuggestions: true,
            spellCheckConfiguration: const SpellCheckConfiguration.disabled(),
            style: baseText.copyWith(color: jade, fontWeight: FontWeight.w600),
            cursorColor: jade,
            onSubmitted: (_) => onSend(),
            decoration: InputDecoration(
              hintText: 'Schnell notieren … (Ctrl/Cmd+Enter fügt an)',
              hintStyle: hintStyle,
              border: InputBorder.none,
              isCollapsed: true,
              suffixIconConstraints: const BoxConstraints.tightFor(width: 128, height: 40),
              suffixIcon: Row(
                mainAxisSize: MainAxisSize.min,
                children: [
                  Tooltip(
                    message: isRecording ? 'Aufnahme stoppen' : 'Sprechen',
                    child: IconButton(
                      onPressed: onMicToggle,
                      icon: Icon(
                        isRecording ? Icons.stop_circle_rounded : Icons.mic_rounded,
                        color: jade,
                      ),
                    ),
                  ),
                  Tooltip(
                    message: 'Anfügen',
                    child: IconButton(
                      onPressed: hasText ? onSend : null,
                      icon: Icon(
                        Icons.keyboard_return_rounded,
                        color: hasText ? jade : jade.withValues(alpha: .45),
                      ),
                    ),
                  ),
                ],
              ),
            ),
          );
        },
      ),
    );
  }
}

// ---------------- Kleiner lokaler TickerProvider -----------------------------
class _TickerProvider extends ChangeNotifier implements TickerProvider {
  _TickerProvider(this._state);
  final State _state;
  @override
  Ticker createTicker(TickerCallback onTick) => Ticker(onTick);
}
